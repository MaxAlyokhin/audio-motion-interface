// План разработки
// Сначала локальный режим (чтобы понять, стоит оно того по звуку или нет),
// потом уже эксперименты с websocket
// 1 тестовый стенд - интерфейс ручек
// 2 изучаем как подружить данные со звуком (какие датчики использовать)
// 3 решаем что оставить пользователю из настроек
// 4 вебсокет

// нужно чтобы motion возвращал чисто данные
// тогда можно будет переключать вызываемый по событию колбек

//// 2
// Только акселерометр:
// параметры звука это константы, акселерометр определяет частоту
// Это скучный (плоский) вариант, подойдёт для тестов типа "какие бывают звуки"

// Комбинация датчиков:
// акселерометр определяет громкость
// гироскоп частоту
// т.е. положение есть настройка звука, а скорость есть его громкость

// Мы можем сделать частоту только по одной из осей

// Нужен ли гироскоп? Он выдаёт статические параметры
// Акселерометр говорит по каким осям с какой скоростью идёт движение
// По сути совмещая положение и скорость

//// Нужно сделать тестовый стенд в ручками управления и данными:
// - TODO: чувствительности акселерометра
// - TODO: троттлинг (события генерятся со скоростью 16 мс; можно сделать больше
//   для облегчения вычислений); этот параметр должен коррелировать
//   с exponentialRampToValueAtTime, т.е. затуханием звука, чтобы всё сливалось
//   в непрерывный звук
// - TODO: статус программы (active, disactive), по сути удаление/добавление слушателей событий
// - TODO: данные с датчиков (6 параметров)
// - TODO: данные звука
// - TODO: интерфейс изменения параметров звука (при изменении пересоздавать audioContext что ли?)
// - TODO: добавить отображение статуса ws на стороне смартфона ("точек синтеза не обнаружено")

import { motionInit } from './motion'

window.addEventListener('DOMContentLoaded', () => {
  // Показываем контент
  document.querySelector('body').style.opacity = 1

  // Кнопка Run запускает алгоритм
  document.querySelector('.button.run').addEventListener(
    'click',
    function () {
      motionInit()
      this.classList.add('run--is-running')
    },
    // Сработает только один раз
    { once: true }
  )

  // Вывод ошибок на экран
  let errorElement = document.querySelector('.errors')
  window.addEventListener('error', (event) => {
    errorElement.innerHTML += `
      <div class="errors__message">${event.error.message}</div>
      <div>${event.error.stack}</div>
    `
  })
})
